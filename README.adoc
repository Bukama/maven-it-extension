= Overview


== Basic Idea

Idea is to create an extension which supports writing integration tests for Maven plugins etc. in a
convenient way. Also thinking of the integration tests of Maven itself.

Basic Idea is currently similar to maven-invoker-plugin:
Another option would be to combine this with Docker containers which run Maven.
Extension starts the appropriate Maven version via ProcessBuilder with parameters in it's own directory (`target/maven-it/ ...` )

Setups which are needed can be defined via `@BeforeEach` or `@BeforeAll` (NEED TO THINK ABOUT IT) annotated methods in JUnit Jupiter.

[source,text]
----
target
 +--- maven-its
         +--- package
                +--- NameOfTheTestClass1
                        +--- .m2/
                        +---- project
                        +----
                +--- NameOfTheTestClass2
                        +--- .m2/
                        +---- project
                        +----
----

Each test should have it's own .m2 Cache directory to get them completely decoupled from each other.

[source,text]
----
target
 +--- maven-its
         +--- first
                +--- .m2/
                +---- project
                +----
         +--- second
                +---
                +---
                +---
----

It is possible to define the cache for several test cases globally which can simply being done by using the following anntation parameter `mavenCache=MavenCache.Global`.
This give the opportunity to make different tests share the same cache which is like a usual setup for a user on a local machine which can be used to test different scenarios.
The other possible value is the default which is `mavenCache=MavenCache.Local` which means having the cache locally to each test case.
This will separate each integration test case from each other.

[source,java]
.FirstMavenIT.java
----
@MavenIT(mavenCache = MavenCache.Global)
class FirstMavenIT {


}
----

As mentioned earlier that each test case has it's own cache.
The drawback of this is that it increases the runtime of the test overall.

Default is to use a commond `$HOME/.m2/repository` cache.

[source,java]
.SecondMavenIT.java
----
@MavenIT
class FirstMavenIT {

  @MavenTest
  void first_test_case(MavenLog log, MavenResult result) {
    result.isSuccessful();
  }


}
----

== Execution of Maven itself

* How to get the Maven version which is defined?
** Define within the same pom file you run your tests?
** Ok could be downloaded from Central?
** how to handle repository managers?
* Where to get configured all the avialble Maven versions?
On the system?
or should we simply download it always to be sure?

== Parameter Injection

Possible options:

* Information about the built project
** version, GAV etc. maybe the whole POM tree ?
** think more in details?
* Logging output
** Stdout
** StdErr
** Log Output as Stream or after finished running
** Convenience methods to get information from the log
*** `isInfo()` which relates to `[INFO] ..` Think about this?
*** Some things to get output from plugins etc.???
* Access to the cache directory
** With convenience methods to access artifacts/content of artifacts
** ???
* general build result.

=== MavenExecutionResult

* MavenExecutionResult
** isSuccessful() `BUILD SUCCESS`
** isError() `[ERROR]....`
** is

[source,java]
.ThirdMavenIT.java
----
@MavenIT
class FirstMavenIT {

  @MavenTest
  void first_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isSuccessful();
  }
  @MavenTest
  void second_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isFailed();
  }

}
----

=== Run Conditionally Integration Tests

You might want to run an integration test only for a particular Maven version for example running only for Maven 3.6.0?

[source,java]
.ForthMavenIT.java
----
@MavenIT
class FirstMavenIT {

  @MavenTest
  @EnabledForMaven(versions=M3_6_0)
  void first_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isSuccessful();
  }

  @DisabledForMaven(version=M3_0_5)
  @MavenTest
  void second_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isFailed();
  }

}
----

So not run some tests on particular Java version can be handled via usual JUnit Jupiter things like:

[source,java]
.FivthMavenIT.java
----
@MavenIT
@DisabledOnJre(JAVA_10)
class FirstMavenIT {

  @MavenTest
  @EnabledForMaven(versions={M3_6_0})
  void first_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isSuccessful();
  }

  @DisabledForMaven(version={M3_0_5})
  @MavenTest
  void second_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isFailed();
  }
}
----



== Assertions in Maven Tests

What kind of assertions do I need to express:

 * Build itself has successfully ended or failed. (Return code?)
 * Log File contains several information
 ** Different levels `INFO`,  `WARN` or `ERROR`..
 *** contains simply one or more lines text
 *** contains only once or multiple appearance of texts
 * StdErr output contains particular output or should not contain particular output.
 * The `target` directory of the built project contains
   either:
 ** particular files
 *** simply exist/do not exist?
 *** should exist or should not exist
 *** The files contain particular content? for example or in general directory within
     the file `MANIFEST.MF`.
 *** A packaged file  special content?
 ** directories
 ** ??

[source,java]
.SixthMavenIT.java
----
@MavenIT
class FirstMavenIT {

  @MavenTest
  void first_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isSuccessful();
  }

  @MavenTest
  void second_test_case(MavenExecutionResult result) {
    assertThat(result).isFailed().log().contains().plugin("G:A:V");
    assertThat(result).isSuccess().project("G:A:V").module("G:A:V").target().jar().metainf
  }
}
----


=== Target Directory Handling

[source,java]
.SeventhMavenIT.java
----
import static org.apache.maven.jupiter.assertj.MavenProjectResultAssert.assertThat;

import org.apache.maven.jupiter.extension.MavenIT;
import org.apache.maven.jupiter.extension.MavenTest;
import org.apache.maven.jupiter.extension.maven.MavenProjectResult;

@MavenIT
class FirstMavenIT {

  @MavenTest
  void second_test_case(MavenProjectResult project) {
    assertThat(project).hasTarget()
        .withEarFile()
        .containsOnlyOnce(
            "META-INF/application.xml",
            "META-INF/appserver-application.xml"
        );
  }
  @MavenTest
  void third_test_case(MavenProjectResult project) {
    assertThat(project).hasTarget()
        .withEarFile()
        .doesNotContain("commons-io-1.4.jar")
        .containsOnlyOnce(
            "commons-lang-commons-lang-2.5.jar",
            "META-INF/application.xml",
            "META-INF/MANIFEST.MF"
        );
  }
}
----






=== Things which do not work yet (not complete!)

This is:

 * Currently it is not possible to define the version Maven only within the test case.
Unfortunately we have to define it in the Maven pom which is used to download the needed package from Central.

